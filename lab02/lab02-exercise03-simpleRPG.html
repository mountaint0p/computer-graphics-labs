<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Class 02 Mini Excercise 02</title>
	</head>
	<body>
		<script type="text/javascript">
			// Using class to represent RPG game
			// TODO: Add the following to the class
			// Enemy: if touched, player will lose and cannot move
			// Coins: if touched, player score goes up (score will be printed with map)
			// Walls: cannot be passed by player
			// These all should be passed to the class via a array of (x, y) coordinates
			class RPG {
				constructor(worldWidth, worldHeight, playerStartX, playerStartY, goalX, goalY, obstacles = [], enemies = [], coins = []) {
					/*
					assume obstacles, enemies, and coins are n x 2 arrays
					symbols:
					8 -> player
					$ -> goal
					0 -> coin
					x -> enemy
					~ -> obstacle
					*/
					
					// below line taken from <https://stackoverflow.com/q/16512182> and its answers
					this.worldState = [...Array(worldHeight)].map(_ => Array(worldWidth).fill(","));
					this.playerX = playerStartX;
					this.playerY = playerStartY;
					// IMPORTANT: we index with y first, then x
					this.worldState[playerStartY][playerStartX] = "8";
					this.worldState[goalY][goalX] = "$";
					
					for (let i = 0; i < obstacles.length; i++) {
						let ob = obstacles[i];
						this.worldState[ob[1]][ob[0]] = "~";
					}
					for (let i = 0; i < coins.length; i++) {
						let co = coins[i];
						this.worldState[co[1]][co[0]] = "0";
					}
					for (let i = 0; i < enemies.length; i++) {
						let en = enemies[i];
						this.worldState[en[1]][en[0]] = "x";
					}
					this.playerCoins = 0;
					
					this.printWorld("Welcome!");
					window.addEventListener("keydown", this.keyDownFunction(this));
				}

				printWorld(messageStr, end = false) {
					let worldStr = "";
					if (end) {
						worldStr = messageStr + `\nFinal score: ${this.playerCoins}`;
						// remove control, end game
						window.removeEventListener("keydown", this.keyDownFunction(this));
					} else {
						worldStr = `Score: ${this.playerCoins}\n`;
						worldStr += this.worldState.map(arr => arr.join("")).join("\n");
						worldStr += "\n" + messageStr;
					}
					console.clear();
					console.log(worldStr);
				}
				
				canMoveTo(x, y) {
					let out_of_bounds = x < 0 || x >= this.worldState[0].length || y < 0 || y >= this.worldState.length;
					if (out_of_bounds) {
						return false;
					}
					return this.worldState[y][x] !== "~";
				}
				
				keyDownFunction(rpg_obj) {
					// Using currying to allow event listener function to use RPG class object
					function eventFunction(event) {
						let targetX = rpg_obj.playerX;
						let targetY = rpg_obj.playerY;
						if (event.key === "ArrowDown") {
							targetY += 1;
						} else if (event.key === "ArrowUp") {
							targetY -= 1;
						} else if (event.key === "ArrowRight") {
							targetX += 1;
						} else if (event.key === "ArrowLeft") {
							targetX -= 1;
						}
						if (rpg_obj.canMoveTo(targetX, targetY)) {
							// TODO handle intersection with coin, enemy, goal before overwriting
							rpg_obj.worldState[rpg_obj.playerY][rpg_obj.playerX] = ","
							rpg_obj.playerX = targetX;
							rpg_obj.playerY = targetY;
							rpg_obj.worldState[rpg_obj.playerY][rpg_obj.playerX] = "8"
							// for MVP just move & print
							rpg_obj.printWorld("");
						} else {
							// can't move there, so tell them & do nothing to the map
							rpg_obj.printWorld("You can't move there!");
						}
					}
					return eventFunction;
				}
			}

			let game = new RPG(20, 10, 9, 6, 1, 1);
		</script>
	</body>
</html>
